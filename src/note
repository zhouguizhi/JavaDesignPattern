1:建造者设计模式-->属于创建型
也叫build模式,这个模式在什么场景下会使用呢?在一个对象属性很多,而且设置对象的属性值,我们在java中要设置对象的属性值,一般有二个方法
一个是通过构造函数,一个是通过set方法去给属性赋值,那么如果一个对象有20个属性的话,那么如果是通过构造函数进行赋值的话,我们要对应每个行参的意思
这样就开发者就很困难,虽然现在的IDE很智能,会给你提示,但是多了也会容易出错,而set方法就比较不容易出错了
建造者角色分析:



2:动态代理


3:设计模式的分类
a:创建型模式:用于描述怎么创建对象,它的主要特点是将对象的创建与使用分离,主要有单例,原型,工厂方法,抽象工厂,建造者设计模式
b:结构型模式:描述的是如何将类或者对象按某种布局组成更大的结构,有代理,适配器,桥接,装饰,外观,享元,组合等设计模式
c:行为型模式:用于描述类或者对象之间怎样互相协作共同完成单个对象无法独立完成的任务,以及怎样分配职责.有模版方法,策略,命令,职责链,状态,观察者,中介者,迭代器,访问者,备忘录,解释器设计模式




4:类与类之间的关系
a:关联关系:是对象之间的一种引用关系,用于表示一类对象与另一类对象之间的关联,如老师与学生,师傅与徒弟,丈夫和妻子,关联关系是类与类之间最常用的一种关系,分为一般关联关系,聚合关系和
组合关系,一般关联又可以分为单向关联,双向关联,自关联
在这里说的引用是指在一个类中声明了一个类的引用,也就是在一个类中有一个另一个类的成员变量
聚合关系:是关联关系的一种,是强关联关系,是整体和部分的关系,聚合关系也是通过成员对象类实现的,其中成员对象是是整体对象的一部分,但是成员对象可以脱离整体对象而独立存在
比如:学校与老师的关系 学校包含老师,  如果学校不存在了,老师依然存在
组合关系:组合表示类之间的整体与部分之间的关系,但它是一种更强烈的聚合关系,在组合关系中,整体对象可以控制部分对象的生命周期,一旦整体对象不存在了,那么部分对象也不会存在了
部分对象不能脱离整体对象存在而存在,如:头和嘴巴,人和头等

依赖关系:它是对象之间耦合度最弱的一种关联关系,是临时的关联,在代码中,某个类的方法通过局部变量(也就是在一个类中的方法要使用到其他类作为局部变量使用),方法的参数或者静态方法的调用来访问另一个类中的某些方法类完成一些功能
继承关系:就是java中的继承一样,继承关系也叫泛化关系
实现关系:和java中实现是一个意思


5:软件设计原则
软件设计原则有6种,而且23种设计模式也是要遵循这6大设计原则的
a:开闭原则:对扩展开放,对修改关闭,在程序需要扩展的时候,不能去修改原来的代码,要达到这个效果,我们要实现接口或者抽象类,因为抽象灵活性好,适应性广,只要抽象的合理,就可以基本保持软件架构的
稳定,而软件中易变的细节可以从抽象派生来的实现类来进行扩展,当软件需求发生变化的时候,只需要根据需求重新派生一个实现类来扩展就可以了
b:里氏代换原则:任何基类可以出现的地方,子类一定可以出现,通俗理解:子类可以扩展父类的功能,但不能改变原有的功能,换句话说, 子类继承父类后,除新添加方法完成新增功能后,尽量不要重写父类的方法,
如果通过重写父类的方法来完成新功能,这样写虽然简单,但是整体继承体系可复用性比较差,特别是运用多态比较频繁时,程序运行出错的概率比较大
c:依赖倒置原则:高层模块不应该依赖低层模块,二者都应该依赖抽象,抽象不依赖细节(具体的实现或者实现类),细节应该依赖抽象(也就是说不要依赖类,应该依赖抽象类或者接口),简单的说就是要求对抽象进行编程,不要对实现进行编程,这样就降低了客户与实现模块间的耦合
d:接口隔离原则:客户端不应该被迫依赖它不使用的方法,一个类对另一个类的依赖应该建立在最小的接口之上
e:迪米特原则(最少知道原则):核心思想是：低耦合、高内聚,一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度
f:单一职责原则:每个类,方法,框架只负责一个功能,比如Math类只负责四舍五入,Reader只负责读取文本文件
g:组合优于继承原则


6:单例设计模式
分类
a:懒汉式:首次使用才会去创建该类的对象
b:饿汉式:类加载就会去创建该类的对象
静态内部类实现单例:由于JVM在加载外部类过程中,是不会加载静态内部类的,只有内部类的属性或者方法被调用时才加载,并初始化静态属性,静态属性由于被static修饰,保证只被实例化一次,并且严格保证实例化顺序
枚举实现单例:因为枚举类型是线程安全的,并且只会加载一次,设计者充分利用了枚举这个特性来实现单例,枚举的写法非常简单,而且枚举类型是所有单例实现中唯一一种不会被破坏的单例实现模式,枚举属于饿汉式

单例存在的问题
使用反射或者序列化可以破坏单例,让其生成多个对象,


7:设计模式的分类
创建型设计模式:描述怎么去创建一个对象,让对象的创建和使用分离,创建型设计模式有:单例,工厂,建造者,原型
结构型设计模式:描述怎么将类或对象按照某种布局组成一个更大的结构, 比如:适配器,桥接模式,装饰模式,组合模式,外观模式,享元模式,代理模式
行为型设计模式:描述类或对象之间怎么相互协作去共同完成单个对象无法完成的工作,主要是分配一些职责,模版方法,命令模式,迭代器模式,观察者模式,中介模式,备忘录模式,
解释器模式,状态模式,策略模式,访问者模式,职责链模式

测试








